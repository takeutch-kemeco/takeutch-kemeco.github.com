#include <stdio.h>
#include <stdlib.h>
#include <string.h>

main()
{
        int* a = malloc(sizeof(*a) * 100);

        int* p = a + 10;
        *p = 123; /* !!! あ、あぶなーーーーい */

        printf("a[10] : [%d]\n", a[10]); /* 無事 123 と表示される。*/
                                         /* どうやら p はちゃんとポインタとして使えてるようだ… */



        /* 紆余曲折があって… */



        /* たとえば自動的に可変長する配列などをやってたとする*/
        int* b = malloc(sizeof(*a) * 200);
        memcpy(b, a, sizeof(*a) * 100);
        free(a);
        a = b; /* ギラリ… */



        /* また紆余曲折があって… */



        /* A */

        *p = 234; /* !!! もう、このポインターを使ってはダメなのに… */

        printf("a[10] : [%d]\n", a[10]); /* p のミスに気づいてないので、*/
                                         /* 234 がセットされてるのを期待してるが、123のまま… */

        /* B */
}



/*
大体ありがちなのは、A ～ B の範囲を眺めながら、
「*p = 234 で、たしかに代入してるのに・・・なぜだ！？」と悩むケース。

ポインターが外れてるのに気づかず使ってしまって、変な挙動させるケースは、慣れた人でもよくあるはず。

しかも厄介なのは、
もしも、何かの拍子で、可変長されなかった場合だと、このバグは起こらない。
だから、実行の度に、発生したり、しなかったりな、気まぐれで厄介なバグとなる。
俗に言う原因がわかりずらいバグ。



上記のような短いコードならすぐ分かるが、
実際の数百行のファイルが複数あるようなソースコードだと、
（この手のパターンで起こりうるバグを知らなければ）、原因の見当すら付けられずに、３、４日printf()とgdb使って悩みつづけるパターンへ突入する。
おそろしい。
*/

